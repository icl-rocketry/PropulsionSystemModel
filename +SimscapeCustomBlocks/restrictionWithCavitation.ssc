component restrictionWithCavitation
% Restriction With Cavitation
% This models a restriction in a two phase network with a resistance
% specified from it's flow coefficient (In Imperial units - Cv).
% Currently assumes turbulent mostly liquid inlet (NOT appropriate for gas inlet or or laminar flows currently...)
% Uses equations from https://www.controlglobal.com/assets/Media/MediaManager/RefBook_Cashco_Fluid.pdf
% to model critical two phase regime

nodes
    A = foundation.two_phase_fluid.two_phase_fluid; % A:left
    B = foundation.two_phase_fluid.two_phase_fluid; % B:right
end

inputs
    % Flow coefficient (C_v, Imperial Units)
    Cv = 10; % Cv:left
end

parameters
    area             = {0.01, 'm^2'}; % Cross-sectional area at ports A and B
    F_L = 0.45; % Liquid Pressure Recovery Factor (F_L, Approx 0.45 for ball valves)
end

% Parameter checks
equations
    assert(Cv > 0)
end

variables (Access=protected)
    mdot_A = {0, 'kg/s'}; % Mass flow rate into port A
    mdot_B = {0, 'kg/s'}; % Mass flow rate into port B
    Phi_A  = {0, 'kW'  }; % Energy flow rate into port A
    Phi_B  = {0, 'kW'  }; % Energy flow rate into port B
end

variables (Access=protected, ExternalAccess=none)
    u_A        = {1500, 'kJ/kg' }; % Specific internal energy at port A
    u_B        = {1500, 'kJ/kg' }; % Specific internal energy at port B
    P_Vap_in = {0, 'MPa'}; %Vapour pressure for same temp as at inlet
end

branches
    mdot_A : A.mdot -> *;
    mdot_B : B.mdot -> *;
    Phi_A  : A.Phi  -> *;
    Phi_B  : B.Phi  -> *;
end

equations
    let
        % Port pressure
        p_A = A.p;
        p_B = B.p;

        % Normalized internal energy
        unorm_A = foundation.two_phase_fluid.normalized_internal_energy(u_A, p_A, ...
            A.u_min, A.u_max, A.p_TLU, A.u_sat_liq_TLU, A.u_sat_vap_TLU);
        unorm_B = foundation.two_phase_fluid.normalized_internal_energy(u_B, p_B, ...
            A.u_min, A.u_max, A.p_TLU, A.u_sat_liq_TLU, A.u_sat_vap_TLU);

        % Specific volume
        v_A = tablelookup(A.unorm_TLU, A.p_TLU, A.v_TLU, unorm_A, p_A, interpolation=linear, extrapolation=linear);
        v_B = tablelookup(A.unorm_TLU, A.p_TLU, A.v_TLU, unorm_B, p_B, interpolation=linear, extrapolation=linear);
        
        % Inlet and outlet pressure, unorm and specific volumes
        [p_in, unorm_in, v_in, unorm_out, v_out, dP, direction] = ...
            if ge(p_A, p_B), ...
                p_A; ...
                unorm_A; ...
                v_A; ...
                unorm_B; ...
                v_B; ...
                p_A - p_B; ...
                1
            else ...
                p_B; ...
                unorm_B; ...
                v_B; ...
                unorm_A; ...
                v_A; ...
                p_B - p_A; ...
                -1
            end;
        
        %Temp at inlet
        T_in = tablelookup(A.unorm_TLU, A.p_TLU, A.T_TLU, unorm_A, p_in, interpolation=linear, extrapolation=linear);
        
        %Inlet specific gravity (rho/rho_water)
        rho_water = {997, 'kg/m^3'};
        specific_gravity = 1 / (rho_water * v_A);
        
        %Turbulent liquid, non choked
        volumetric_flow_rate = {0.000277778 * 0.865 * Cv * (value(dP, 'bar')/specific_gravity)^0.5, 'm^3/s'};
        
        % Mass flow rate
        mdotUnchoked = direction * (volumetric_flow_rate / v_in);
        
        %Velocity at A
        velocity_A = (mdot * v_A) / area;
        
        %Liquid Critical Pressure Ratio Factor
        F_f = 0.96 - 0.28 * (P_Vap_in / A.p_crit)^0.5;
        
        %Vena contracta min pressure
        P_vc = F_f * P_Vap_in;
        
        %"dP allow" - Above this dP full choking occurs
        dPChokeThreshold = F_L^2 * (p_in - P_vc);
        
        %Turbulent flow, choked
        dPChoked = p_in - P_vc;
        volumetric_flow_rate_choked = {0.000277778 * 0.865 * Cv * F_L * (value(dPChoked, 'bar')/specific_gravity)^0.5, 'm^3/s'};
        
        %Mass flow rate
        mdotChokedVal = direction * (volumetric_flow_rate_choked / v_in);
        
        %Mass flow rate, blending between unchoked and choked as needed
        %NOT appropriate for gas phase...
        mdot = simscape.function.blend(mdotUnchoked, mdotChokedVal, max(0, p_in - P_Vap_in), dPChokeThreshold, dP);
    in
        %Solve for P_Vap at inlet temperature
        T_in == tablelookup(A.unorm_TLU, A.p_TLU, A.T_TLU, 0, P_Vap_in, interpolation=linear, extrapolation=linear);
        
        % Mass flow rate
        mdot_A == mdot;
        
        % Pick specific internal energy such that process is isenthalpic
        u_A + p_A*v_A == u_B + p_B*v_B;
        
        convection_A.ht_I == u_A + p_A*v_A + velocity_A^2/2;
        
        % Mass balance
        mdot_A + mdot_B == 0;

        % Energy balance
        Phi_A + Phi_B == 0;

        % Run-time variable checks
        assert(A.p >= A.p_min, message('physmod:simscape:library:two_phase_fluid:PressureMinValid', 'A'))
        assert(A.p <= A.p_max, message('physmod:simscape:library:two_phase_fluid:PressureMaxValid', 'A'))
        assert(A.u >= A.u_min, message('physmod:simscape:library:two_phase_fluid:InternalEnergyMinValid', 'A'))
        assert(A.u <= A.u_max, message('physmod:simscape:library:two_phase_fluid:InternalEnergyMaxValid', 'A'))
        assert(B.p >= B.p_min, message('physmod:simscape:library:two_phase_fluid:PressureMinValid', 'B'))
        assert(B.p <= B.p_max, message('physmod:simscape:library:two_phase_fluid:PressureMaxValid', 'B'))
        assert(B.u >= B.u_min, message('physmod:simscape:library:two_phase_fluid:InternalEnergyMinValid', 'B'))
        assert(B.u <= B.u_max, message('physmod:simscape:library:two_phase_fluid:InternalEnergyMaxValid', 'B'))

        % Equate variables for internal components that calculate energy convection at ports A and B
        convection_A.mdot == mdot_A;
        convection_A.Phi  == Phi_A;
        convection_B.mdot == mdot_B;
        convection_B.Phi  == Phi_B;

        convection_A.ht_I == convection_B.ht_I;
    end
end

% Internal components that calculate energy convection at ports A and B
components (ExternalAccess=none)
    convection_A = foundation.two_phase_fluid.port_convection(flow_area = area, length_scale = sqrt(4*area/pi));
    convection_B = foundation.two_phase_fluid.port_convection(flow_area = area, length_scale = sqrt(4*area/pi));
end

connections
    connect(A, convection_A.port)
    connect(B, convection_B.port)
end

end